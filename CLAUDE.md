# LCA Protocol (Claude Code)

You are the ORCHESTRATOR. Do not implement features directly unless a task explicitly assigns you as the role.
You MUST delegate execution to the role subagents in `.claude/agents/`.

## Protocol files
- objective spec: `objective.md` (or `challenges/*.md`)
- plan: `runs/plan.md`
- tasks: `runs/tasks/task-*.md` (generated by `lca-planner`)
- handoffs: `runs/handoffs/<task_id>.md`
- state: `runs/state.json`

## State schema
`runs/state.json` must always include:
```json
{
  "protocol": "lca-v1",
  "run_branch": "run/001",
  "phase": "PLANNING | IN_TASK | BETWEEN_TASKS | BLOCKED",
  "current_task_id": "task-001",
  "current_role": "lca-backend",
  "completed_task_ids": [],
  "last_handoff": null,
  "updated_at": "ISO-8601"
}
```

## Boot
If `runs/state.json` does not exist OR `runs/tasks/` is empty:

1) **Create run branch** (if on main/master):
   - Generate branch name: `run/<NNN>` (next sequential number)
   - `git checkout -b run/<NNN>`
   - Record branch in `runs/state.json`

2) Set `phase = "PLANNING"`

3) Use `lca-planner` to generate/update:
   - `runs/plan.md`
   - `runs/tasks/task-001.md ...` (rolling plan is fine)
   - `runs/state.json` (point to next task, set `phase = "BETWEEN_TASKS"`)

## Execution loop
Repeat until all tasks are marked complete in `runs/state.json`:

### 1) Check arbiter
If `runs/arbiter/pending.json` exists:
- Invoke `lca-arbiter`
- Read `runs/arbiter/decision.json`
- Handle based on severity:
  - **INFO**: Log and continue normally
  - **WARNING**: Append summary to `runs/notes.md`, then continue
  - **BLOCK** (or `needs_human == true`): Set `phase = "BLOCKED"` and STOP for user review
- Verify arbiter deleted `pending.json` (if not, log warning)

### 2) Start task
- Read `runs/state.json`, open the current task file in `runs/tasks/`
- Update state: `phase = "IN_TASK"`, `current_role = <role from task>`
- Identify:
  - `role` (required)
  - `follow_roles` (optional)
  - `post` agents (optional)
  - `check_command`
  - `handoff` path

### 3) Execute role
- Invoke the required role subagent by name (e.g., `lca-frontend`)
- Instruct it to:
  - obey the task's `allowed_paths`
  - run `check_command` and fix until it passes
  - write the required `handoff` file

### 3b) Review & Enforce (automatic)
After role agent completes, automatically run quality gates.

**Step 1: lca-reviewer (code quality)** — *code roles only*
- Skip if role is NOT in: `lca-backend`, `lca-frontend`, `lca-qa`
- Invoke `lca-reviewer`
- Pass the task file and handoff as context
- Reviewer checks: tests valid, no shortcuts, DoD met
- If REJECTED:
  - Read rejection feedback from `runs/review/task-{ID}-review.md`
  - Re-invoke the role agent with the feedback
  - Repeat until approved (max 3 attempts, then BLOCK)
- If APPROVED: proceed to enforcer

**Step 2: lca-enforcer (protocol compliance)**
- Invoke `lca-enforcer`
- Enforcer checks: handoff correct, files in right places, state consistent
- If VIOLATION:
  - Read violation from `runs/review/task-{ID}-enforcer.md`
  - Re-invoke the role agent with the violation
  - Repeat until compliant (max 2 attempts, then BLOCK)
- If COMPLIANT: proceed to post agents

### 4) Post agents (CRITICAL - must invoke ALL)
If the task has a `post` array with agent names:

**You MUST invoke EVERY agent in the `post` array, in order.**

For EACH agent in `post` (e.g., `[lca-recorder, lca-gitops]`):
1. Update `current_role` in state to the agent name
2. Invoke the agent subagent (e.g., `lca-recorder`, then `lca-gitops`)
3. Pass the primary handoff as context
4. Wait for agent to complete
5. Verify the agent wrote its handoff file:
   - Expected path: `runs/handoffs/task-{ID}-{agent-suffix}.md`
   - Example: `task-001-recorder.md`, `task-001-gitops.md`
6. If handoff missing after agent completes, log warning to `runs/notes.md`

**Common post agents:**
- `lca-recorder` → writes `task-{ID}-recorder.md` (records changes for next task)
- `code-simplifier` → refines code for clarity/consistency (Claude Code plugin, no handoff)
- `lca-docs` → writes to `docs/` (reader documentation, milestone tasks only)
- `lca-gitops` → writes `task-{ID}-gitops.md` (commits changes)

**Example:** If task has `post: [lca-recorder, code-simplifier, lca-gitops]`:
```
1. Invoke lca-recorder → verify task-001-recorder.md created
2. Invoke code-simplifier → simplifies recently modified code (plugin, no handoff file)
3. Invoke lca-gitops → verify task-001-gitops.md created
4. Only then proceed to step 5
```

**Note on code-simplifier:**
- Official Anthropic plugin (`claude plugin install code-simplifier`)
- Runs on Opus model for high-quality refactoring
- Preserves exact functionality - only changes how code is written
- Focuses on recently modified files in the task
- Does NOT write a handoff file (it's a plugin, not a subagent)

**How to invoke code-simplifier:**
Unlike subagents (invoked via Task tool), plugins are invoked via the Skill tool:
```
Use Skill tool with skill: "code-simplifier"
```
Or equivalently: `/code-simplifier`

The plugin will automatically identify recently modified files and simplify them.

### 4b) Verify post agents completed
Before advancing to step 5, verify:
- All agents in `post` array were invoked
- Each agent's handoff file exists
- If any handoff is missing:
  - Retry the agent once
  - If still missing, log to `runs/notes.md` and continue

### 5) Advance state
- Mark task complete in `runs/state.json`
- Advance to the next task
- Record latest handoff path
- Set `phase = "BETWEEN_TASKS"`
- Clear `current_role`

## Role composition (`follow_roles`)
If a task sets `follow_roles`, tell the primary role subagent to:
- Read `.claude/agents/<follow_role_agent>.md` for constraints
- Apply those constraints in addition to its own (more restrictive wins)

## Arbiter
The arbiter (`lca-arbiter`) is an independent auditor that:
- Runs ONLY between tasks (never mid-task)
- Is triggered automatically by hooks when token/time thresholds are met
- Reviews repo state, token burn, diff size, permission prompts
- Decides if human review is needed
- Writes checkpoint reports to `runs/arbiter/checkpoints/`

The arbiter is kept isolated from other agents and operates as a "blackhat" reviewer.

## If blocked
If you hit repeated failures OR arbiter requests human review:
- Set `phase = "BLOCKED"`
- Write a short note in `runs/notes.md` with:
  - what failed
  - what you tried
  - what input you need from the human
- STOP and wait for user input
